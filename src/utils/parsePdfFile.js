// src/utils/parsePdfFile.js
// Use pdfjs-dist for robust PDF text extraction (Vite-compatible)
import * as pdfjsLib from 'pdfjs-dist';
// Set workerSrc to CDN for browser compatibility
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

/**
 * Parse PDF exported from Cipher Playground and extract metadata, input, output.
 * Only works for PDFs generated by this app (structured format).
 * @param {ArrayBuffer} arrayBuffer
 * @returns {Promise<{meta: object, inputText: string, outputText: string}>}
 */
export async function parsePdfFile(arrayBuffer) {
  // Kirim buffer sebagai Array agar tidak terjadi detached ArrayBuffer di Windows/Chrome
  const loadingTask = pdfjsLib.getDocument({ data: Array.from(arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer)) });
  const pdf = await loadingTask.promise;
  let text = '';
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    const pageText = content.items.map(item => item.str).join('\n');
    text += pageText + '\n';
  }
  // Parse the text as if it were a TXT export, but also support table-style (key\nvalue) for metadata
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const meta = {};
  let inMeta = false, inInput = false, inOutput = false;
  let inputText = '', outputText = '';
  let lastMetaKey = null;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (/^PARAMETER/i.test(line)) { inMeta = true; inInput = false; inOutput = false; lastMetaKey = null; continue; }
    if (/^INPUT/i.test(line)) { inMeta = false; inInput = true; inOutput = false; lastMetaKey = null; continue; }
    if (/^OUTPUT/i.test(line)) { inMeta = false; inInput = false; inOutput = true; lastMetaKey = null; continue; }
    if (/^=+/.test(line) || /^-+/.test(line)) continue;
    if (inMeta) {
      // Table style: key on one line, value on next line
      if (lastMetaKey) {
        meta[lastMetaKey.toLowerCase()] = line;
        lastMetaKey = null;
        continue;
      }
      // If line is a known meta key, set as lastMetaKey
      if (/^(method|mode|shift|rails|key|keytype|blocksize|pattern|casestrategy|foreignmode|vigenerekey|addrandompadding)$/i.test(line)) {
        lastMetaKey = line;
        continue;
      }
      // Fallback: colon style
      if (/:/.test(line)) {
        const [k, ...v] = line.split(':');
        meta[k.trim().toLowerCase()] = v.join(':').trim();
        lastMetaKey = null;
        continue;
      }
    } else if (inInput) {
      inputText += line + '\n';
    } else if (inOutput) {
      outputText += line + '\n';
    }
  }
  inputText = inputText.trim();
  outputText = outputText.trim();
  return { meta, inputText, outputText, fullText: text };
}
